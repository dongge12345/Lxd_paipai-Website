1.动态获取本地图片的方法
    图片放置在assets文件中。
    在img标签中将图片的src设置为动态方法，方法中使用require将前面的路径比如'@/assets/'，拆分为如require('@/assets/' + url)也就是动静结合的方式。

2.修改样式属性：
    获取样式属性：getComputedStyle(container).getPropertyValue('--w') / dom.style.getPropertyValue('--crackW)
    修改样式属性：dom.style.setProperty('--crackW',crackW)

3.js代码实现animation动画的添加和已有动画的获取
    获取已有动画：element.getAnimations()
    添加动画：element.animate([{},{},{}])
    在路由跳转前后执行，实现loading效果：
        // 手写路由跳转时的loading
        let loading = document.createElement('div')
        loading.classList.add('loading')
        let loadingStyleObj = {
            position: "absolute",
            top:"50%",
            left:"50%",
            width: "30px",
            height:"30px",
            border: "2px dotted",
            borderColor: "red black",
            borderRadius: "50%",
            animation:"loadingAct 2s infinite linear",
            zIndex:10000000
        }

        for(let attrName in loadingStyleObj){
            loading.style[attrName] = loadingStyleObj[attrName]
        }
        loading.animate([{transform:'translate(-50%,-50%) rotate(0deg) '},{transform:' translate(-50%,-50%) rotate(360deg) '}],{iterations:Infinity,duration:1000})

        document.body.appendChild(loading)
        router.beforeEach((to,from,next)=>{
            console.log('进行路由跳转了')
            loading.style.display = "block"
            next()
        })
        router.afterEach((to,from)=>{
            // 路由跳转太快看不到loading效果，所以设置延时器看一下
            setTimeout(()=>{
                loading.style.display = "none"
            },100)
        })

4.utils文件夹的使用：
    可以用于使用js封装一些复用的组件，比如loading效果、弹窗组件等；
5.原生js和html实现浏览器摄像头的打开、拍照功能、视频的录制、视频图片的下载。
    1.摄像头的打开和关闭以及实时显示：
        navigator.MediaDevices.getUserMedia({video:true}).then(stream=>{
            video.srcObject = stream
        })
    2.拍照需要借助canvas画布：canvas.getContext('2d').drawImage(video,left,top,right,bottom)
    3.视频录制：--声音也需要开启
        let videoData = []
        navigator.MediaDevices.getUserMedia({video:true,audio:true}).then(stream=>{
            video.srcObject = stream

            // 创建录制音视频的收集器对象
            let recorder = new MediaRecorder(stream) // 这里不同的stream会转化为不同类型的mediaRecorder，比如这里的recorder的mimeType为video音视频类型。
            // 数组存储数据
            recorder.ondataavaliable = (e)=>{
                videoData.push(e.data)
            }
            // 录制完成后将数组数据转为blob的音视频流
            recorder.onstop = ()=>{
                let blob = new Blob(videoData,{type:stream.mimeType})
                // 获取音视频流对应的dataUrl
                let href = URL.createObjectURL(blob)
                let a = document.createElement('a')
                a.href = href
                a.download = '此处为下载时图片的名字'
                a.click() //模拟下载
                // 收尾工作
                URL.revokeObjectURL(a.href)
                a.remove()

            }
        })

        某个click:recorder.start()
        某个click:recorder.stop() 此时将全局的dataVideo = []重置为空数组
    部署上线后发现摄像头无法打开，navigator.mediaDevices为undefined：
        何时navigator.mediaDevices不为undefined？
            1.地址为localhost
            2.地址为file://
            3.https://开头
        而http情况下摄像头是无法开启的。


6.动态照片墙：
    问题：图片下载未完成后执行函数导致图片布局混乱，找不到执行布局照片墙函数的事件点？
    解决：使用imgDom.complete属性判断图片是否加载完成。遍历照片墙的所有图片，当有图片还未加载完成时，等待0.1秒后再次执行布局照片墙的函数。

7.使用js方式实现loading多种效果的函数并封装到utils文件夹中供全局的调用。

8.scale后不再居左靠齐，使用translateX()使之永远居左的计算公式。
    <div style="scale:0.5;transform:translateX(calc(100% / 0.5 * (1 - 0.5)  / 2 * -1))">
    这里100% / 0.5是因为据观察，scale后100%不再表示设置的div原长度，而是scale后的长度，所以通过100% / 倍数0.5就可以算出div的原长度。